<!DOCTYPE html>

<head>
<!-- saved from url=(0028) https://emsansone.github.io/ -->
<!-- <html class=" js no-touch rgba hsla textshadow opacity svg" lang="en"><!--<![endif]-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-169038417-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-169038417-1');
</script>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Emanuele Sansone</title>
<meta name="description" content="Emanuele Sansone">
<meta name="keywords" content="Jekyll, theme, responsive, blog, template">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Emanuele Sansone">
<meta name="twitter:description" content="Emanuele Sansone">



<!--<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://emsansone.github.io/img/Background3.jpg">-->

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Emanuele Sansone">
<meta property="og:description" content="Emanuele Sansone">
<meta property="og:url" content="https://emsansone.github.io/blog/">
<meta property="og:site_name" content="Emanuele Sansone">





<link rel="canonical" href="https://emsansone.github.io/blog/">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://emsansone.github.io/assets/css/main.css">
    
<meta http-equiv="cleartype" content="on">
        
<!-- Modernizr -->
<script src="https://emsansone.github.io/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>
        
<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://emsansone.github.io/img/logo.png">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://emsansone.github.io/img/logo-32x32.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://emsansone.github.io/img/logo-57x57.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://emsansone.github.io/img/logo-72x72.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://emsansone.github.io/img/logo-114x114.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://emsansone.github.io/img/logo-144x144.png">

<style>
  table, th, td {
    border: 1px solid grey;
    border-collapse: collapse;
  }
</style>

</head>

<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true }
    }
});
</script>

<body class="page">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="https://emsansone.github.io/">Website</a>
	</div><!-- /.site-name -->
    <div class="top-navigation">
        <nav role="navigation" id="site-nav" class="nav">
		    <ul>
              <li><a href="https://emsansone.github.io/blog/rl/rl0.htm">Index</a></li>	        					    
					    <li><a href="https://emsansone.github.io/blog/rl/rl8.htm" >Previous Lecture</a></li>
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->


<!--<div class="image-wrap">
    <img src="https://emsansone.github.io/img/Background3.jpg" alt="Emanuele Sansone feature image">
</div>-->

<div id="main" role="main">
  <div class="article-author-side">
    <img src="https://emsansone.github.io/img/Me.jpg" class="bio-photo" alt="Emanuele Sansone bio photo">

    <h2>Emanuele Sansone</h2>
    <p>PhD in machine learning and artificial intelligence.</p>
    <a href="mailto:e.sansone@hotmail.it" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/email.png" height=14px width=14px> Email</a>

    <a href="https://linkedin.com/in/emanuele-sansone-97329475" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/linkedin.png" height=14px width=14px> LinkedIn</a>

    <a href="https://twitter.com/skiera87" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/twitter.png" height=14px width=14px> Twitter</a>

    <!-- <a href="https://github.com/emsansone" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/github.png" height=14px width=14px> Github</a> -->
  </div>

  <article class="page">

    <div class="article-wrap" style="width:140%;text-align:justify;">
    
      <h1 id="Lecture-9:-Exploitation-and-Exploration">Exploration and Exploitation Dilemma</h1>
      <p>In this lecture, we study the dilemma of exploitation and exploration. Exploration aims at <strong>collecting information</strong> and exploitation aims at <strong>using the information to gain as much reward as possible</strong>.
      <br>The problem of exploration and exploitation can be analyzed in the <strong>multi-armed bandit</strong> setting,
      which is the most fundamental and simplest problem in reinforcement learning. The insights achieved by the theoretical analysis can be also helpful for more complex problems, like <strong>contextual bandits</strong> and full <strong>MDPs</strong>.</p>

      <h1 id="Multi-Armed-Bandit">Multi-Armed Bandit</h1>
      <p>The multi-armed bandit problem is defined by the tuple $&lt;A,R&gt;$, where $A$ is a finite set of actions (or <strong>arms</strong>) and $R$ is the reward function. At each time step, an arm needs to be chosen and a reward is drawn from an unknown density $p(r|a)$. The agent must select the arm which maximizes the conditional expected reward.
      <br>We define the action-value function $q(a)=E\{R|A=a\}$ (note that the environment is equivalent to a 1-step MDP) and the optimal action is given by $a^*=\arg\max_a q(a)$.</p><br/>
      <p style="text-align: center;"><img src="./img/Arm.png" alt="Arms"></p><br/>
      <p>Unfortunately, the densities associated to each arm are unknown and the agent must be able to balance exploring new arms and exploiting the knowledge of already visited arms. In general, the agent incurs in a loss when taking decisions. We define the <strong>regret</strong> at time as $t$ $I_t=E\{q(a^*)-q(a_t)\}$ and the total regret as $L_t=E\{\sum_{\tau=1}^t q(a^*)-q(a_\tau)\}$.
      <br>Note that</p>
      $$\begin{align}
          L_t &amp;= E\Big\{\sum_{\tau=1}^t q(a^*)-q(a_\tau)\Big\} \\
              &amp;= \sum_{a\in A}\big(q(a^*)-q(a)\big)E\{N_t(a)\} \quad\text{where}\quad N_t(a)=\text{# times action is picked} \\
              &amp;= \sum_{a\in A}\Delta_a E\{N_t(a)\} \quad\text{where}\quad \Delta_a=\big(q(a^*)-q(a)\big)\text{ is called gap}
      \end{align}$$<br/>
      <p><strong>Minimizing the total regret consists of picking more frequently actions with low gap.</strong> The total regret is an indicator which tells which algorithm is able to explore/exploit optimally.</p>

      <h2 id="Algorithm-Analysis:-Greedy-Algorithms">Algorithm Analysis: Greedy Algorithms</h2>
      <p>A greedy algorithm has two steps:</p>
      <ol>
      <li>Action-value estimation, through Monte-Carlo estimation $Q_t(a)=\frac{1}{N_t(a)}\sum_{\tau=1}^t1[a_\tau=a]r_\tau$.</li>
      <li>Choose arm greedily $a_t=\arg\max_a Q_t(a)$</li>
      </ol>
      <p>Note that greedy algorithms incur in <strong>linear total regret</strong>. Once a wrong action is taken, the algorithm can continue to pick that action, thus adding the same gap at each timestep.
      To understand this phenomenon consider the following example</p><br/>
      <p style="text-align: center;"><img style="width:60%;height:60%" src="./img/Case.png" alt="Case"></p><br/>
      <p>Suppose that there are three arms $a_1,a_2,a_3$ and that</p>
      <ol>
      <li>$a_1$ is the optimal arm visited only few times</li>
      <li>$a_2$ and $a_3$ are visited many times</li>
      </ol>
      <p>Now, the greedy algorithm performs a Monte-Carlo estimate of the average reward for each arm. This estimate has lower variance for frequently visited arms than rarely visited ones (see the curves for each arm in the picture).
      Note that the algorithm chooses the arm greedily and it always selects arm $a_3$. This choice is suboptimal.</p>

      <h2 id="Algorithm-Analysis:-$\epsilon$-Greedy-Algorithms">Algorithm Analysis: $\epsilon$-Greedy Algorithms</h2>
      <p>A common strategy is to introduce random exploration in the arm selection stage. In fact, we can pick a random arm with probability $\epsilon$ and pick arm $a_t=\arg\max_a Q_t(a)$ with probability $1-\epsilon$.
      <br>This strategy avoids to get stuck to selecting wrong arms. Nevertheless, it is suboptimal because noise is introduced at each time step. To understand this, consider previous example. Action $a_2$ can be selected even though we are almost sure that it is not optimal and therefore we are wasting decisions.
      <br>Note that</p>
      $$E\{N_t(a)\}=\frac{\epsilon t}{|A|-1}\geq\frac{\epsilon t}{|A|}$$<br/>
      <p>Therefore (by recalling the relation between total regret and the total number of visits for arm $a$)</p>
      $$L_t\geq \frac{\epsilon t}{|A|}\sum_{a\in A}\Delta_a$$<br/>
      <p>Therefore, greedy algorithms incur in <strong>linear total regret</strong>.</p><br/>
      <p><strong>Question.</strong> Can we do better?<br>
      Yes, one strategy is to perform <strong>optimistic initialization</strong> (all actions are initially good) and then we can act greedily. This is a trick that works particularly well in practice, but it has no theoretical guarantee on the performance.
      <br>Yes, we can also decay $\epsilon$, but in general it is difficult to devise a theoretically grounded strategy for decaying it.</p><br/>
      <p><strong>Question.</strong> Can we do better by guaranteeing a sublinear total regret?</p>

      <h2 id="Algorithm-Analysis:-Optimal-Algorithm">Algorithm Analysis: Optimal Algorithm</h2>
      <p>In 1985 Lai and Robbins showed that the total regret of any algorithm for the multi-armed bandit can be lower bounded, namely:</p>
      $$E\{N_t(a)\}\geq\frac{\log t}{KL\big\{p(r|A=a)||p(r|A=a^*)\big\}} \quad\text{for}\quad t\rightarrow\infty$$<br/>
      <p>and therefore (by recalling the relation between total regret and the total number of visits for arm $a$)</p>
      $$L_t\geq \log t\sum_{a\neq a^*}\frac{\Delta_a}{KL\big\{p(r|A=a)||p(r|A=a^*)\big\}} \quad\text{for}\quad t\rightarrow\infty$$<br/>
      <p>The optimal algorithm achieves an asymptotical <strong>logarithmic total regret</strong>.</p><br/>
      <p><strong>Question.</strong> How can we achieve that?<br>
      The answer can be obtained by considering the example described above. Note that, the most uncertain action $a_1$ has the biggest potential to be the optimal one (the tail on the right is the highest one), whereas we can confidently say that action $a_2$ is likely to be worse than action $a_3$ as the estimates differ and have low variance. Therefore, we can balance exploration and exploitation by taking into account <strong>the estimates together with their uncertainty</strong>.</p>

      <h2 id="Algorithm-Analysis:-Upper-Confidence-Bound-(UCB)">Algorithm Analysis: Upper Confidence Bound (UCB)</h2>
      <p>Instead of considering only the estimate of the action-value function, we can consider an upper bound on the estimate and ensure that the true value is smaller than the bound with very high probability.</p>
      <p>At this purpose, we can recall the Hoeffding's inequality.</p>
      <blockquote><p><strong>Hoeffding's inequality</strong>. Given a random variable $X$ defined on the $[0,1]$ sample space. If we get an i.i.d set of samples $x_1,...,x_t$ and define the sample mean $\bar{x}_t=\frac{1}{t}\sum_{\tau=1}^tx_\tau$, then</p>
      $$P\big(E\{X\}&gt;\bar{x}_t+u\big)\leq e^{-2tu^2}$$<br/>
      </blockquote>
      <p>Now, we can use it for our estimates. In fact, assume that the reward is defined on $[0,1]$, we have that $Q_t(a)=\frac{1}{N_t(a)}\sum_{\tau=1}^t1[a_\tau=a]r_\tau$. Therefore,</p>
      $$P\big(q(a)&gt;Q_t(a)+U_t(a)\big)\leq e^{-2N_t(a)U_t(a)^2}$$<br/>
      <p>We define probability $p=e^{-2N_t(a)U_t(a)^2}$, then we get that $U_t(a)=\sqrt{\frac{-\log p}{2N_t(a)}}$.
      <br>And by decreasing $p$ over time (in order to ensure that the true value is finally included with certainty), e.g. $p=t^{-4}$, we obtain that</p>
      $$U_t(a)=\sqrt{\frac{2\log t}{N_t(a)}}$$<br/>
      <p>The UCB algorithm selects actions according to the followig rule:</p>
      $$a_t=\arg\max_a Q_t(a)+\sqrt{\frac{2\log t}{N_t(a)}}$$<br/>
      <p>The paper of <a href="https://link.springer.com/article/10.1023/A:1013689704352">Auer et al. 2002</a> proves that the UCB algorithm satisfies the following bound, namely:</p>
      $$E\{N_t(a)\}\leq\frac{8\log t}{\Delta_a^2}+c_1 \quad\text{for any }t$$<br/>
      <p>where $c$ is a small constant. Therefore (by recalling the relation between total regret and the total number of visits for arm $a$)</p>
      $$L_t\leq 8\log t\sum_{a\neq a^*}\frac{1}{\Delta_a}+c_2 \quad\text{for any }t$$<br/>
      <p>where $c_2$ is a small constant. <strong>UCB achieves logarithmic total regret</strong>.
      <br>The algorithm is not optimal though as the proved bound is worse than the one proved by Lai and Robbins. In fact, you can prove that $KL\{p(r|A=a)||p(r|A=a^*)\}\geq 2\Delta_a^2$, in other words that $\frac{1}{KL\{p(r|A=a)||p(r|A=a^*)\}}\leq \frac{0.5}{\Delta_a^2}$. 
      Therefore, $\frac{1}{KL\{p(r|A=a)||p(r|A=a^*)\}}\leq \frac{0.5}{\Delta_a^2}&lt;\frac{8}{\Delta_a^2}$. The paper of <a href="https://link.springer.com/article/10.1023/A:1013689704352">Auer et al. 2002</a> provides more sophisticated strategies than the UCB algorithm, improving the constant $8$ in the bound by getting closer to $0.5$ (see the paper for further details).</p>

      <h2 id="Algorithm-Analysis:-Bayesian-Upper-Confidence-Bound">Algorithm Analysis: Bayesian Upper Confidence Bound</h2>
      <p>(FOR SCALAR REWARDS)</p><br/>
      <p>Note that our aim is to compute an estimate of the true value $q(a)$ given a set of observations of rewards.
      Let's define $\bar{r}_a=q(a)$ and $\hat{r}_a$ as the sample mean estimate of the true value $\bar{r}_a$. $\hat{r}_a$ is a random quantity and we can assume that it has Gaussian density (by considering that $\bar{r}_a$ is a sample mean estimate and by using the central limit theorem for sufficiently large number of such samples).
      <br>Therefore, we define $p(\hat{r}_a|\mu_a,\sigma_a^2)=\mathcal{N}(\hat{r}_a;\mu_a,\sigma_a^2)$ and a prior $p(\mu_a,\sigma_a^2)$ (which is typical uniform).
      <br>Given the set of all rewards observed up to time $t$ for action $a$,viz. $D_t^a$, the algorithm performs the following steps:</p>
      <ol>
      <li>Compute the posterior for time $t$<br/>
        <span class="math display">\[\begin{align}p(\mu_a,\sigma_a^2|D_t^a) &amp;= \frac{p(D_t^a|\mu_a,\sigma_a^2)p(\mu_a,\sigma_a^2)}{Z} \\
          &amp;\propto p(D_t^a|\mu_a,\sigma_a^2)p(\mu_a,\sigma_a^2) \\
          &amp;= \prod_{r\in D_t^a}p(\hat{r}_a=r|\mu_a,\sigma_a^2) \\
          &amp;= \prod_{r\in D_t^a}\mathcal{N}(\hat{r}_a=r;\mu_a,\sigma_a^2)p(\mu_a,\sigma_a^2)
\end{align}\]</span><br/></li>
      <li>Get $\mu_a$ and $\sigma_a$</li>
      <li>Select arm according to
      $$a_{t+1}=\arg\max_a \mu_a+c\sigma_a$$
      where $c$ is an arbitrary positive integer.</li>
      </ol>
      <p>This algorithm is <strong>optimal</strong> for sufficiently large number of visits for action $a$ and for specific choices of $c$. Nevertheless, there are solutions which do not require setting any hyperparameter.</p>

      <h2 id="Algorithm-Analysis:-Thompson-Sampling">Algorithm Analysis: Thompson Sampling</h2>
      <p>Assume that we have:</p>
      <ul>
      <li>a set of observations $D=\{(a_1,r_1),\dots,(a_t,r_t)\}$</li>
      <li>a parametric reward probability $p(r|a,\theta)$</li>
      <li>a prior over parameters, $p(\theta)$</li>
      </ul>
      <p>Note that greedy algorithms attempt to maximize</p>
      $$\begin{align}
          q(a) &amp;= E\{R|A=a,D\} \\
               &amp;= \int r p(r|A=a,D) dr \\
               &amp;= \int r \int p(r|A=a,D,\Theta=\theta)p(\theta|A=a,D) d\theta dr \\
               &amp;= \int \int r p(r|A=a,D,\Theta=\theta) dr p(\theta|A=a,D) d\theta \\
               &amp;= \int E\{R|A=a,D,\Theta=\theta\}p(\theta|A=a,D)d\theta
      \end{align}$$<br/>
      <p>Thompson sampling approaches the problem differently, in the sense that it attempts to estimate $p(a\text{ is optimal}|D)$ and maximize it. In fact,</p>
      $$\begin{align}
          p(a\text{ is optimal}|D) &amp;= \int p(a\text{ is optimal},\Theta=\theta|D) d\theta \\
                                           &amp;= \int p(a\text{ is optimal}|\Theta=\theta,D) p(\theta|D) d\theta \\
                                           &amp;= \int 1\big[E\{R|A=a,\Theta=\theta,D\}=\max_{a'}E\{R|A=a',\Theta=\theta,D\}\big]p(\theta|D) d\theta
      \end{align}$$<br/>
      <p>Basically, this integral performs a partition of the parameter space $\Theta$ (where each region has its own optimal actions) and uses the posterior $p(\theta|D)$ to compute $p(a\text{ is optimal}|D)$ for all $a$. See the following picture for an example of 2 dimensional parameter space</p><br/>
      <p style="text-align: center;"><img style="width: 50%;height: 50%;" src="./img/Partition.png" alt="Parameter"></p><br/>
      <p>Computing the integral is usually intractable. Therefore, one can</p>
      <ol>
      <li>Compute the posterior $p(\theta|D)$.</li>
      <li>Sample $\theta$ (or get a bunch of samples) from the posterior $p(\theta|D)$.</li>
      <li>Compute $E\{R|A=a,\Theta=\theta,D\}$ for all $a$.</li>
      <li>Choose with probability 1 the action corresponding to the highest $E\{R|A=a,\Theta=\theta,D\}$.</li>
      </ol>
      <p>Note that these steps are different from greedy algorithms. In fact, we choose action $a$ proportionally to its probability of being optimal (in other words we perform <strong>probability matching</strong>).
      <br>To better understand the difference with respect to greedy algorithms, let's consider the case of binary rewards (Bernouilli bandits). In this case, we have that $p(\theta|D)=\prod_{a\in A}p(\theta_a|D)$.
      <br>In greedy algorithms, we have that</p>
      $$\begin{align}
          q(a) &amp;= E\{R|A=a,D\} \\
               &amp;= \sum_{r\in\{0,1\}}r \int Be(r|\theta_a)p(\theta_a|D) d\theta_a \\
               &amp;= \int \theta_a p(\theta_a|D) d\theta_a \quad\text{as}\quad \theta_a=p(r=1|A=a,D)\\
      \end{align}$$<br/>
      and we choose the arm with highest mean value of parameter posterior (<strong>we compute an expectation over the whole parameter space</strong>).
      <br>In Thompson sampling, we maximize<br/>
      $$p(a\text{ is optimal}|D)=\int 1\big[\theta_a=\max_{a'}\theta_a'\big]p(\theta_a|D) d\theta_a$$<br/>
      In this case, <strong>we integrate only on the region of the parameter space for which the arm is optimal</strong>.
      <strong>Note that Thompson sampling achieves logarithmic total regret in Bernouilli bandits</strong>.</p>

      <h2 id="Algorithm-Analysis:-Algorithms-based-on-Information-State">Algorithm Analysis: Algorithms based on Information State</h2>
      <p>Assume that we have:</p>
      <ul>
      <li>a parametric reward probability $p(r|a,\theta)$</li>
      <li>a conjugate prior over parameters, $p(\theta)$</li>
      </ul>
      <p>An <strong>information state</strong> is defined to capture all information available so far.
      In the case of Bernouilli bandits, the reward probability is a Bernouilli distribution $Be(\theta_a)$ and the parameter prior is the Beta distribution $B(\alpha_a,\beta_a)$. The information state is defined as the vector containing the hyperparameters of the Beta prior, namely $\tilde(s)=[\alpha_1,\beta_1,\dots,\alpha_K,\beta_K]$.</p>
      <p>By using the definition of information state, we can define a MDP, namely $&lt;\tilde{S},A,\tilde{P},R,\gamma&gt;$. <strong>Note that in the case of conjugate priors, the hyperparameters can be computed in closed form</strong> (for example in Bernouilli bandits $\alpha_a\leftarrow\alpha_a+1$ if $r=1$ and $\beta_a\leftarrow\beta_a+1$ if $r=0$). <strong>This is important because we know the transition probability $\tilde{P}$ and we can use dynamic programming to find the optimal strategy</strong>. For this reasons, algorithms based on information state are optimal to balance exploration and exploitation.</p>
      <p>If dynamic programming cannot be used, we can use other RL algorithms (that we have already introduced in previous lectures).</p>

      <h1 id="Contextual-Bandit">Contextual Bandit</h1>
      <p>A contextual bandit is a tuple $&lt;A,S,R&gt;$, where</p>
      <ul>
      <li>we have an unknown density over states $p(s)$</li>
      <li>we have a density for rewards $p(R=r|S=s,A=a)$</li>
      </ul>
      <p>Note that a contextual bandit introduces states compared to multi-armed bandits. Furthermore, it differs from the full RL setting, as the states are not influenced by any action or previous state (therefore we don't have a transition probability between states).</p>
      <p>Contextual bandits have been used for personalized web advertising. Each state is used to describe the specific preferences of each user, actions are used to select which advertising to display to the user and rewards consists of advertising clicks made by each user.</p><br/>
      <p><strong>Example from </strong><a href="http://proceedings.mlr.press/v26/li12a/li12a.pdf">Paper</a>
      <br>Consider the following setting:</p>
      <ul>
      <li>a linear reward model $r_s^a=\phi(s,a)^T\mu, \phi(s,a)^T\Sigma\phi(s,a)\theta$</li>
      <li>Gaussian prior over the parameters $\theta\sim\mathcal{N}(\mu,\Sigma)$ with diagonal $\Sigma$</li>
      <li>a dataset of observations $D=\{(s_1,a_1,r_1),\dots,(s_T,a_T,r_T)\}$</li>
      </ul>
      <p>Then, we know that $r$ is a linear transformation of random vector $\theta$, thus $r_s^a\sim\mathcal{N}\big(\phi(s,a)^T\mu, \phi(s,a)^T\Sigma\phi(s,a)\big)$.
      <br>The proposed algorithm maximizes the following objective with respect to $\mu,\Sigma$</p>
      $$\begin{align}
          \log p(D|\mu,\Sigma) &amp;= \log\prod_{i=1} p(s_i,a_i,r_i|\mu,\Sigma) \\
                               &amp;= \sum_{i=1}\log p(r_i|s_i,a_i;\mu,\Sigma)p(s_i,a_i) \quad\text{consider uniform prior} \\
                               &amp;= \sum_{i=1}\log p(r_i|s_i,a_i;\mu,\Sigma) \\
                               &amp;= \sum_{i=1}\log \mathcal{N}\big(\phi(s_i,a_i)^T\mu, \phi(s_i,a_i)^T\Sigma\phi(s_i,a_i)\big)
      \end{align}$$<br/>
      <p>Afterwards, it selects actions for given state $s'$ by using the following upper confidence bound</p>
      $$\begin{align}
          a^* &amp;= \arg\max_a \phi(s',a)^T\mu^* + c\sqrt{\phi(s',a)^T\Sigma^*\phi(s',a)}
      \end{align}$$<br/>

      <h1 id="Full-MDPs">Full MDPs</h1>
      <p>The same principles used in multi-armed bandits can be applied to the full MDP problem.
      Please, see the slides of <a href="https://www.davidsilver.uk/teaching/">David Silver</a> for further details on this.</p>

      <h1 id="Final-Remarks">Final Remarks</h1>
      <p>It is important to mention that there are other factors that have to be considered when dealing with exploration and exploitation. For example, in extremely large state spaces it is not possible to explore all possible states. Therefore, we need to decide which subset of states to explore. Another example consists of safety-concerned applications, where state exploration must provide some safety guarantees.</p>
            
      
    </div><!-- /.article-wrap -->

    <div id="disqus_thread" style="width:140%;text-align:justify;margin-top:3cm;margin-bottom:2cm;"></div>
    <script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://ema87.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
            
  </article>
</div><!-- /#index -->
                    

<div class="footer-wrap">
  <footer>
<span>&copy; 2020 Emanuele Sansone.

  </span></footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://emsansone.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://emsansone.github.io/assets/js/scripts.min.js"></script>

</body></html>
