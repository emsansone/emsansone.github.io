<!DOCTYPE html>

<head>
<!-- saved from url=(0028) https://emsansone.github.io/ -->
<!-- <html class=" js no-touch rgba hsla textshadow opacity svg" lang="en"><!--<![endif]-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-169038417-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-169038417-1');
</script>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Emanuele Sansone</title>
<meta name="description" content="Emanuele Sansone">
<meta name="keywords" content="Jekyll, theme, responsive, blog, template">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Emanuele Sansone">
<meta name="twitter:description" content="Emanuele Sansone">



<!--<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://emsansone.github.io/img/Background3.jpg">-->

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Emanuele Sansone">
<meta property="og:description" content="Emanuele Sansone">
<meta property="og:url" content="https://emsansone.github.io/blog/">
<meta property="og:site_name" content="Emanuele Sansone">





<link rel="canonical" href="https://emsansone.github.io/blog/">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="https://emsansone.github.io/assets/css/main.css">
    
<meta http-equiv="cleartype" content="on">
        
<!-- Modernizr -->
<script src="https://emsansone.github.io/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>
        
<link href='//fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700%7CPT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="https://emsansone.github.io/img/logo.png">
<!-- 32x32 -->
<link rel="shortcut icon" href="https://emsansone.github.io/img/logo-32x32.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="https://emsansone.github.io/img/logo-57x57.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://emsansone.github.io/img/logo-72x72.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://emsansone.github.io/img/logo-114x114.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://emsansone.github.io/img/logo-144x144.png">

</head>

<!-- Load mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: false }
    }
});
</script>

<body class="page">

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="https://emsansone.github.io/">Website</a>
	</div><!-- /.site-name -->
    <div class="top-navigation">
        <nav role="navigation" id="site-nav" class="nav">
		    <ul>
              <li><a href="https://emsansone.github.io/blog/atp/atp0.htm">Index</a></li>	        					    
					    <li><a href="https://emsansone.github.io/blog/atp/atp2.htm" >Previous Lecture</a></li>
					    <li><a href="https://emsansone.github.io/blog/atp/atp4.htm" >Next Lecture</a></li>

		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->


<!--<div class="image-wrap">
    <img src="https://emsansone.github.io/img/Background3.jpg" alt="Emanuele Sansone feature image">
</div>-->

<div id="main" role="main">
  <div class="article-author-side">
    <img src="https://emsansone.github.io/img/Me.jpg" class="bio-photo" alt="Emanuele Sansone bio photo">

    <h2>Emanuele Sansone</h2>
    <p>PhD in machine learning and artificial intelligence.</p>
    <a href="mailto:e.sansone@hotmail.it" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/email.png" height=14px width=14px> Email</a>

    <a href="https://linkedin.com/in/emanuele-sansone-97329475" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/linkedin.png" height=14px width=14px> LinkedIn</a>

    <a href="https://twitter.com/skiera87" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/twitter.png" height=14px width=14px> Twitter</a>

    <!-- <a href="https://github.com/emsansone" class="author-social" target="_blank"><img src="https://emsansone.github.io/img/github.png" height=14px width=14px> Github</a> -->
  </div>

  <article class="page">

    <div class="article-wrap" style="width:140%;text-align:justify;">

      <h2 id="Proving-Conjectures-in-First-Order-Logic">Proving Conjectures in First-Order Logic</h2>
      <p><strong>Ingredients</strong></p>
      <ul>
      <li>Here we introduce <strong>terms</strong> like <strong>variables, constants and quantifiers</strong>.</li>
      <li>Furthermore, we have <strong>functions of terms</strong> which are also terms. </li>
      <li><strong>Predicates</strong> are boolean functions. </li>
      </ul>
      <p>Considering the same example used in propositional logic. The example is valid for any two people that know each other. In this case, <strong>propositional logic</strong> requires to list all people knowing each other. First-order logic allows to <strong>compactly represent this fact</strong>, namely <em>For every x and y, if x knows y, then y knows x</em>.<br/>
      Therefore, <strong>first-order logic is more expressive than propositional logic</strong>.<br/><br/>
      <strong>FIRST-ORDER LOGIC IS UNDECIDABLE</strong>. <strong>Proof</strong>. given by Alonzo Church in 1935 (note that here you cannot use truth tables)<br/><br/>
      <strong>Definitions</strong></p>
      <ul>
      <li><strong>Literals</strong> are <strong>predicates</strong>.</li>
      <li>A <strong>clause</strong> $C$ is a disjunction of literals $l_1\lor l_2\lor\dots\lor l_n$ or equivalently a set of literals $\{l_1,l_2,\dots,l_n\}$.</li>
      <li>A <strong>clausal form</strong> (expressed in conjuctive normal form, CNF) $\Sigma$ is a conjuction of clauses $C_1\land\dots\land C_c$ or equivalently a set of clauses (a set of sets) $\{C_1,\dots,C_c\}$ specified by a <strong>universal quantifier for the variables, viz $\forall$</strong>.</li>
      </ul>
      <p><strong>Question</strong>. How can we check the validity of conjectures (or equivalently refute conjectures)? Also in this case we can derive an inference rule based on resolution. But firstly, we need to introduce the notion of <strong>substitution</strong>, <strong>unifier</strong> and <strong>most general unifier</strong>, namely:</p>
      <blockquote><p><strong>Substitution</strong>. A substitution $\sigma$ on the set of variables is performing a renaming/assigning operation to all variables in the set. E.g. we have an expression $\phi$ defined over the set of variables $\{X,Y\}$, $\sigma=\{X\leftarrow a, Y\leftarrow Y'\}$ applies the operations to $\phi$. The new expression is identified by $\phi\sigma$.<br/><br/>
      <strong>Unifier</strong>. A substitution $\sigma$ is a unifier for two expressions $\phi$ and $\psi$ iff $$\phi\sigma=\psi\sigma$$ If two expressions $\phi$ and $\psi$ have a unifier, they are <strong>unifiable</strong>.<br/><br/>
      <strong>Most general unifier</strong>. A substitution $\sigma$ is more general than a substitution $\tau$ iff there exists a substitution $\delta$ such that $\sigma\delta=\tau$. E.g. $\sigma=\{X\leftarrow a, Y\leftarrow V\}$ and $\tau=\{X\leftarrow a, Y\leftarrow c, V\leftarrow c\}$ then $\sigma\{V\leftarrow c\}=\tau$.
      The most general unifier is the most general one.</p>
      </blockquote>
      <p><strong>Two clauses without common variables clash</strong> iff there is a literal $l_1$ in $C_1$ and a literal $l_2$ in $C_2$, such that $l_1$ and $\neg l_2$ are unifiable. For example, if $C_1=\{P(X,Y),\dots\}$ and $C_2=\{\neg P(X',a),\dots\}$, then $P(X,Y)$ and $P(X',a)$ are unifiable by the substitution $\{X\leftarrow X',Y\leftarrow a\}$. 
      Then, the <strong>binary resolvent</strong> $C$ of clashing clauses $C_1$ and $C_2$ is given by $$C=(C_1\setminus\{l_1\}\cup C_2\setminus\{l_2\})\sigma$$
      where $\sigma$ is the most general unifier between the two clauses.</p>
      <blockquote><p><strong>Resolution</strong>. Given a clausal form $\Sigma$, resolution takes two clashing clauses $C_1,C_2$ computes the binary resolvent $C$ and add it to the clausal form. We can easily prove that $\{C_1,C_2,C\}$ preserves the truth of $\Sigma$.</p>
      </blockquote>
      <p><strong>Example</strong></p>
      <div style="overflow: auto"><span class="math display">\[\begin{array}{ll}
        1. \{\neg P(X),Q(X),R(X,f(X))\} &amp; \\
        2. \{\neg P(X),Q(X),S(f(X))\} &amp; \\
        3. \{T(a)\} &amp; \\
        4. \{P(a)\} &amp; \\
        5. \{\neg R(a,Y),T(Y)\} &amp; \\
        6. \{\neg T(X),\neg Q(X)\} &amp; \\
        7. \{\neg T(X),\neg S(X)\} &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; 
        \end{array}
        \quad\rightarrow\quad
        \cdots
        \quad\rightarrow\quad
        \begin{array}{ll}
        1. \{\neg P(X),Q(X),R(X,f(X))\} &amp; \\
        2. \{\neg P(X),Q(X),S(f(X))\} &amp; \\
        3. \{T(a)\} &amp; \\
        4. \{P(a)\} &amp; \\
        5. \{\neg R(a,Y),T(Y)\} &amp; \\
        6. \{\neg T(X),\neg Q(X)\} &amp; \\
        7. \{\neg T(X),\neg S(X)\} &amp; \\
        8. \{\neg Q(a)\} &amp; \text{resolve 3,6 with }\sigma=\{X\leftarrow a\} \\
        9. \{Q(a),S(f(a))\} &amp; \text{resolve 2,4 with }\sigma=\{X\leftarrow a\} \\
        10. \{Q(a),R(a,f(a))\} &amp; \text{resolve 1,4 with }\sigma=\{X\leftarrow a\} \\
        11. \{S(f(a))\} &amp; \text{resolve 8,9} \\
        12. \{R(a,f(a))\} &amp; \text{resolve 8,10} \\
        13. \{T(f(a))\} &amp; \text{resolve 5,12 with }\sigma=\{Y\leftarrow f(a)\} \\
        14. \{\neg S(f(a))\} &amp; \text{resolve 11,14 with }\sigma=\{Y\leftarrow f(a)\} \\
        15. \perp &amp; \text{resolve 11,14}
        \end{array}\]</span></div>
        <br/><br/>

      <strong>Theorem</strong>. Binary resolution is <strong>sound but not complete for refutation</strong>.<br/>
      <strong>Proof</strong>: Soundness can be trivially proved, while we can derive a counterexample for completeness.
      In fact, we can have unsatisfiable arguments which cannot be detected by resolution. Consider<br/><br/>
      <div style="overflow: auto"><span class="math display">\[\begin{array}{ll}
        1. \{P(X),P(Y)\} &amp; \\
        2. \{\neg P(X&#39;), \neg P(Y&#39;)\} &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        &amp; \\
        \end{array}
        \quad\rightarrow\quad
        \dots
        \quad\rightarrow\quad
        \begin{array}{ll}
        1. \{P(X),P(Y)\} &amp; \\
        2. \{\neg P(X&#39;), \neg P(Y&#39;)\} &amp; \\
        3. \{P(Y), \neg P(Y&#39;)\} &amp; \text{resolve 1,2 with }\sigma=\{X\leftarrow X&#39;\} \\
        4. \{P(X), \neg P(X&#39;)\} &amp; \text{resolve 1,2 with }\sigma=\{Y\leftarrow Y&#39;\} \\
        5. \{P(X)\} &amp; \text{resolve 1,4 with }\sigma=\{Y\leftarrow X&#39;\} \\
        6. \{P(Y)\} &amp; \text{resolve 1,3 with }\sigma=\{X\leftarrow X&#39;\} \\
        \dots &amp; \\
        \end{array}
        \]</span></div><br/>
      In fact, we get only tautologies.</li>
      </ol>
      <br/><br/>
      <strong>Question</strong>. How can we make it complete?</p>
      <blockquote><p><strong>Factoring</strong>. For two or more literals in clause $C$ there is a most general unifier $\sigma$. Therefore, you can <strong>replace</strong> the clause with the <strong>factor</strong> $C\sigma$.</p>
      </blockquote>
      <div style="overflow: auto"><span class="math display">\[
        \begin{array}{ll}
            1. \{P(X),P(Y)\} &amp; \\
            2. \{\neg P(X&#39;), \neg P(Y&#39;)\} &amp; \\
        &amp; \\
        \end{array}
        \quad\rightarrow\quad
        \begin{array}{ll}
            1. \{P(X)\} &amp; \text{ factoring with }\sigma={Y\leftarrow X}\\
            2. \{\neg P(X&#39;), \neg P(Y&#39;)\} &amp; \\
        &amp; \\
        \end{array}
        \quad\rightarrow\quad
        \begin{array}{ll}
            1. \{P(X)\} &amp; \text{ factoring with }\sigma={Y\leftarrow X}\\
            2. \{\neg P(X&#39;)\} &amp; \text{ factoring with }\sigma={Y&#39;\leftarrow X&#39;} \\
        &amp; \\
        \end{array}
        \quad\rightarrow\quad
        \begin{array}{ll}
            1. \{P(X)\} &amp; \text{ factoring with }\sigma={Y\leftarrow X}\\
            2. \{\neg P(X&#39;)\} &amp; \text{ factoring with }\sigma={Y&#39;\leftarrow X&#39;} \\
            3. \perp &amp; \text{resolve 1,2 with }\sigma=\{X\leftarrow X&#39;\} \\
        \end{array}
        \]</span></div><br/><br/>
        
      <strong>Theorem</strong>. Binary resolution + factoring is <strong>sound and complete for refutation</strong>.<br/><br/>
      Note that binary resolution + factoring <strong>may not terminate</strong>.<br/><br/>
      <strong>Example of non-termination for satisfiable argument (which we want to refute)</strong></p>
      
      <div style="overflow: auto"><span class="math display">\[
        \begin{array}{ll}
            1. \{Q(Y),\neg Q(f(Y))\} &amp; \\
            2. \{\neg Q(X), \neg P(X)\} &amp; \\
            &amp; \\
            &amp; \\
            &amp; \\
        \end{array}
        \quad\rightarrow\quad
        \dots
        \quad\rightarrow\quad
        \begin{array}{ll}
            1. \{Q(Y),\neg Q(f(Y))\} &amp; \\
            2. \{\neg Q(X), \neg P(X)\} &amp; \\
            3. \{\neg Q(f(X)),\neg P(X)\} &amp; \text{resolve 1,2 with }\sigma=\{Y\leftarrow X\}\\
            4. \{\neg Q(f(f(X))), \neg P(X)\} &amp; \text{resolve 1,3 with }\sigma=\{Y\leftarrow f(X)\}\\
            \dots &amp; \\
        \end{array}
        \]</span></div><br/><br/>

      <p><strong>Example of non-termination for unsatisfiable argument (which we want to refute)</strong><br/>
      It can be constructed from previous case and imagine that resolution + factoring performs the same operations as before <strong>without touching clauses 3 and 4</strong>.</p>

      <div ><span class="math display">\[
        \begin{array}{ll}
            1. \{Q(Y),\neg Q(f(Y))\} &amp; \\
            2. \{\neg Q(X), \neg P(X)\} &amp; \\
            3. \{\neg Q(Y)\} &amp; \\
            4. \{Q(f(Y))\} &amp; \\
        \end{array}
        \]</span></div>

      <h2 id="Improving-Efficiency-for-Proving-Conjectures-in-First-Order-Logic">Improving Efficiency for Proving Conjectures in First-Order Logic</h2>
      <p>Here, we show some strategies used to improve the efficiency of deduction systems.</p>
      <h3 id="Strategy-1:-Ordered-Resolution-Calculus">Strategy 1: Ordered Resolution Calculus</h3>
      <p>Our aim is to check the validity of a formula and in particular check that $\Sigma\models\phi$ for a set of premises $\Sigma$ and a conclusion $\phi$. Equivalently, we can check for unsatisfiability of the negated conjecture, namely $\Sigma\cup\neg\phi\models\perp$.
      Therefore, we can apply resolution refutation to the formula $\Sigma\cup\neg\phi$. Now, consider the example $\Sigma=\phi=\{\{\neg a\},\{\neg b\},\{\neg c\}\}$. Therefore, $\Sigma\cup\neg\phi=\{\{\neg a\},\{\neg b\},\{\neg c\},\{a,b,c\}\}$. In this case, there are different ways to select clauses for resolution and many of them are useless to arrive to a contradiction. Importantly, if <strong>the formula $\Sigma\cup\neg\phi$ is unsatisfiable then all literals belonging of $\neg\phi$ have to disappear</strong>. Based on this consideration, we can specify an <strong>order on literals</strong> to reduce the search space. Inn the previous example, we can decide to resolve for $a$, then for $b$ and then for $c$.
      The <strong>notion of ordering literals can be extended to first-order logic</strong> (soundness and completeness can be still guaranteed).
      Since it is difficult to know a priori what is the optimal ordering to achieve faster convergence to a possible contradiction, <strong>modern automated theorem provers based on resolution refutation typically choose a set of orderings and try all of them</strong>.</p>
      <h3 id="Strategy-2:-Tautology-Elimination">Strategy 2: Tautology Elimination</h3>
      <p>Resolution can produce clauses which are tautologies, like $\{P(f(a)),\neg P(f(a)), Q(Y)\}$. Therefore, at each inference step, we can eliminate possible tautologies. Note that $\{P(f(X)),\neg P(f(a)), Q(Y)\}$ is not a tautology.</p>
      <h3 id="Strategy-3:-Subsumption-Elimination">Strategy 3: Subsumption Elimination</h3>
      <p>The idea behind subsumption elimination is to eliminate clauses which do not add additional information.
      Consider for example two sentences <em>Everyone tells the truth</em> and <em>Jack tells the truth</em>. It's clear that the latter sentence provides no additional information to determine the truth value of the conjuction of the two sentences. Therefore, we can remove it.<br/><br/>
      Let's define subsumption</p>
      <blockquote><p><strong>Subsumption</strong>. $\phi$ subsumes $\psi$ iff there exists a substitution $\sigma$ such that $\phi\sigma\subseteq\psi$. $\phi$ is the <strong>subsuming clause</strong> and $\psi$ is the <strong>subsumed clause</strong>.</p>
      </blockquote>
      <p>We have two kinds of subsumption:</p>
      <ol>
      <li><strong>Forward subsumption</strong>. If resolution generates clause $\psi$ from clauses $\phi_1$ and $\phi_2$ and $\phi_1$ subsumes $\psi$, then $\psi$ does not provide additional information. Therefore, the subsumed clause can be removed.</li>
      <li><strong>Backward subsumption</strong>. If resolution generates clause $\psi$ from clauses $\phi_1$ and $\phi_2$ and $\psi$ subsumes an existing clause $\phi_3$, then we have to wait for $\phi_3$ being deleted before deleting $\psi$.</li>
      </ol>
      <h2 id="Extension-of-Proving-Conjectures-in-First-Order-Logic-with-Equality">Extension of Proving Conjectures in First-Order Logic with Equality</h2>
      <p>Equality relation is fundamental to express many mathematical problems. For example, equality is necessary to describe systems of equations.</p>
      <p><strong>The equality symbol</strong> is defined by <strong>a set of axioms which need to be added to a clausal form</strong>, if we want to prove the validity of a formula. Typically, you need to convert the axioms into conjuctive normal form before proceeding to adding them to the set of clauses. The inclusion of axioms comes with the cost of adding extra complexity to the resolution refutation system (i.e. <strong>resolution needs to deal with more clauses</strong>).</p>
      <p>Nevertheless, there is a set of inference rules, which are guaranteed to <strong>satisfy the equality axioms when applied to resolve/factor clauses with equalities without the need of specifying them</strong>.
        The system using these inference rules is called <strong>paramodulation calculus</strong>. (There is also the extension to <strong>ordered paramodulation calculus</strong> which is proved to be sound and complete). Check <a href="http://profs.sci.univr.it/~farinelli/courses/ar/slides/paramodulation.pdf">HERE</a> + <a href="https://www.youtube.com/watch?v=jvIcitRPTDc">HERE at 1'12''00</a> for more details about paramodulation.</p>
      <p>Nevertheless, ordered paramodulation calculus is still very inefficient due to the use of equalities. The number of clauses in this case still explodes.
        There are other inference rules based on the <strong>Knuth-Bendix completion algorithm</strong> (this algorithm was applied for the term rewriting problem where you have a system of equations in input and you extract a set of rules [which consists of ordered equalities] from it), which allow to deal with equalities in a more efficient way, leading to the so called <strong>superposition calculus</strong>.</p>
            
              
    </div><!-- /.article-wrap -->

    <div id="disqus_thread" style="width:140%;text-align:justify;margin-top:3cm;margin-bottom:2cm;"></div>
    <script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://ema87.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
            
  </article>
</div><!-- /#index -->
                    

<div class="footer-wrap">
  <footer>
<span>&copy; 2020 Emanuele Sansone.

  </span></footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="https://emsansone.github.io/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="https://emsansone.github.io/assets/js/scripts.min.js"></script>

</body></html>
